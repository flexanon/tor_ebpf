/* plug_cell.h -- generated by Trunnel v1.5.3.
 * https://gitweb.torproject.org/trunnel.git
 * You probably shouldn't edit this file.
 */
#ifndef TRUNNEL_PLUG_CELL_H
#define TRUNNEL_PLUG_CELL_H

#include <stdint.h>
#include "trunnel.h"

#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_PLUGIN_PART)
struct plugin_part_st {
  /** length of the whole buffer */
  uint64_t total_len;
  /** length of the payload within this cell */
  uint16_t data_len;
  /**
     * offset is the index of this plugin_data_part's beginning position within the whole
     * plugin_data, which might be greater than one cell payload size
     *
     * 0 <= offset < total_len
     */
  uint64_t offset;
  TRUNNEL_DYNARRAY_HEAD(, uint8_t) plugin_data_part;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct plugin_part_st plugin_part_t;
#if !defined(TRUNNEL_OPAQUE) && !defined(TRUNNEL_OPAQUE_SEND_CELL)
struct send_cell_st {
  uint8_t version;
  uint64_t uid;
  uint16_t length;
  struct plugin_part_st *data_ppart;
  uint8_t trunnel_error_code_;
};
#endif
typedef struct send_cell_st send_cell_t;
/** Return a newly allocated plugin_part with all elements set to
 * zero.
 */
plugin_part_t *plugin_part_new(void);
/** Release all storage held by the plugin_part in 'victim'. (Do
 * nothing if 'victim' is NULL.)
 */
void plugin_part_free(plugin_part_t *victim);
/** Try to parse a plugin_part from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * plugin_part_t. On failure, return -2 if the input appears
 * truncated, and -1 if the input is otherwise invalid.
 */
ssize_t plugin_part_parse(plugin_part_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * plugin_part in 'obj'. On failure, return a negative value. Note
 * that this value may be an overestimate, and can even be an
 * underestimate for certain unencodeable objects.
 */
ssize_t plugin_part_encoded_len(const plugin_part_t *obj);
/** Try to encode the plugin_part from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t plugin_part_encode(uint8_t *output, size_t avail, const plugin_part_t *input);
/** Check whether the internal state of the plugin_part in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *plugin_part_check(const plugin_part_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int plugin_part_clear_errors(plugin_part_t *obj);
/** Return the value of the total_len field of the plugin_part_t in
 * 'inp'
 */
uint64_t plugin_part_get_total_len(const plugin_part_t *inp);
/** Set the value of the total_len field of the plugin_part_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int plugin_part_set_total_len(plugin_part_t *inp, uint64_t val);
/** Return the value of the data_len field of the plugin_part_t in
 * 'inp'
 */
uint16_t plugin_part_get_data_len(const plugin_part_t *inp);
/** Set the value of the data_len field of the plugin_part_t in 'inp'
 * to 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int plugin_part_set_data_len(plugin_part_t *inp, uint16_t val);
/** Return the value of the offset field of the plugin_part_t in 'inp'
 */
uint64_t plugin_part_get_offset(const plugin_part_t *inp);
/** Set the value of the offset field of the plugin_part_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int plugin_part_set_offset(plugin_part_t *inp, uint64_t val);
/** Return the length of the dynamic array holding the
 * plugin_data_part field of the plugin_part_t in 'inp'.
 */
size_t plugin_part_getlen_plugin_data_part(const plugin_part_t *inp);
/** Return the element at position 'idx' of the dynamic array field
 * plugin_data_part of the plugin_part_t in 'inp'.
 */
uint8_t plugin_part_get_plugin_data_part(plugin_part_t *inp, size_t idx);
/** As plugin_part_get_plugin_data_part, but take and return a const
 * pointer
 */
uint8_t plugin_part_getconst_plugin_data_part(const plugin_part_t *inp, size_t idx);
/** Change the element at position 'idx' of the dynamic array field
 * plugin_data_part of the plugin_part_t in 'inp', so that it will
 * hold the value 'elt'.
 */
int plugin_part_set_plugin_data_part(plugin_part_t *inp, size_t idx, uint8_t elt);
/** Append a new element 'elt' to the dynamic array field
 * plugin_data_part of the plugin_part_t in 'inp'.
 */
int plugin_part_add_plugin_data_part(plugin_part_t *inp, uint8_t elt);
/** Return a pointer to the variable-length array field
 * plugin_data_part of 'inp'.
 */
uint8_t * plugin_part_getarray_plugin_data_part(plugin_part_t *inp);
/** As plugin_part_get_plugin_data_part, but take and return a const
 * pointer
 */
const uint8_t  * plugin_part_getconstarray_plugin_data_part(const plugin_part_t *inp);
/** Change the length of the variable-length array field
 * plugin_data_part of 'inp' to 'newlen'.Fill extra elements with 0.
 * Return 0 on success; return -1 and set the error code on 'inp' on
 * failure.
 */
int plugin_part_setlen_plugin_data_part(plugin_part_t *inp, size_t newlen);
/** Return a newly allocated send_cell with all elements set to zero.
 */
send_cell_t *send_cell_new(void);
/** Release all storage held by the send_cell in 'victim'. (Do nothing
 * if 'victim' is NULL.)
 */
void send_cell_free(send_cell_t *victim);
/** Try to parse a send_cell from the buffer in 'input', using up to
 * 'len_in' bytes from the input buffer. On success, return the number
 * of bytes consumed and set *output to the newly allocated
 * send_cell_t. On failure, return -2 if the input appears truncated,
 * and -1 if the input is otherwise invalid.
 */
ssize_t send_cell_parse(send_cell_t **output, const uint8_t *input, const size_t len_in);
/** Return the number of bytes we expect to need to encode the
 * send_cell in 'obj'. On failure, return a negative value. Note that
 * this value may be an overestimate, and can even be an underestimate
 * for certain unencodeable objects.
 */
ssize_t send_cell_encoded_len(const send_cell_t *obj);
/** Try to encode the send_cell from 'input' into the buffer at
 * 'output', using up to 'avail' bytes of the output buffer. On
 * success, return the number of bytes used. On failure, return -2 if
 * the buffer was not long enough, and -1 if the input was invalid.
 */
ssize_t send_cell_encode(uint8_t *output, size_t avail, const send_cell_t *input);
/** Check whether the internal state of the send_cell in 'obj' is
 * consistent. Return NULL if it is, and a short message if it is not.
 */
const char *send_cell_check(const send_cell_t *obj);
/** Clear any errors that were set on the object 'obj' by its setter
 * functions. Return true iff errors were cleared.
 */
int send_cell_clear_errors(send_cell_t *obj);
/** Return the value of the version field of the send_cell_t in 'inp'
 */
uint8_t send_cell_get_version(const send_cell_t *inp);
/** Set the value of the version field of the send_cell_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int send_cell_set_version(send_cell_t *inp, uint8_t val);
/** Return the value of the uid field of the send_cell_t in 'inp'
 */
uint64_t send_cell_get_uid(const send_cell_t *inp);
/** Set the value of the uid field of the send_cell_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int send_cell_set_uid(send_cell_t *inp, uint64_t val);
/** Return the value of the length field of the send_cell_t in 'inp'
 */
uint16_t send_cell_get_length(const send_cell_t *inp);
/** Set the value of the length field of the send_cell_t in 'inp' to
 * 'val'. Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int send_cell_set_length(send_cell_t *inp, uint16_t val);
/** Return the value of the data_ppart field of the send_cell_t in
 * 'inp'
 */
struct plugin_part_st * send_cell_get_data_ppart(send_cell_t *inp);
/** As send_cell_get_data_ppart, but take and return a const pointer
 */
const struct plugin_part_st * send_cell_getconst_data_ppart(const send_cell_t *inp);
/** Set the value of the data_ppart field of the send_cell_t in 'inp'
 * to 'val'. Free the old value if any. Steals the referenceto
 * 'val'.Return 0 on success; return -1 and set the error code on
 * 'inp' on failure.
 */
int send_cell_set_data_ppart(send_cell_t *inp, struct plugin_part_st *val);
/** As send_cell_set_data_ppart, but does not free the previous value.
 */
int send_cell_set0_data_ppart(send_cell_t *inp, struct plugin_part_st *val);


#endif
